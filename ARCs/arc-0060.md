---
arc: 60
title: Algorand Wallet Structured Data Signing API
description: API function for signing structured data
author: Stefano De Angelis (@deanstef)
discussions-to: https://github.com/algorandfoundation/ARCs/issues/284
status: Draft
type: Standards Track
category: Interface
created: 2024-02-28
requires: 1
---

# Algorand Wallet Structured Data Signing API

> This ARC is inspired by [ARC-1](./arc-0001.md).

## Abstract

ARC-1 defines a standard for signing Algorand transactions that are represented as structured objects. This proposal extends the signing process to byte arrays encoded with a standardized structure.  [ARC-60](./arc-0060.md) defines an API for wallets to sign structured data that are not Algorand transactions.

## Motivation

Signing data is a common and critical operation. Users may need to sign data for multiple reasons (e.g. delegate signatures, DIDs, signing documents, authentication).

Algorand wallets need a standard approach to byte signing to unlock self-custodial services and protect users from malicious and attack-prone signing workflows.

This ARC provides a standard API for bytes signing. The API encodes byte arrays to be signed into well-structured JSON schemas together with additional metadata. It requires wallets to validate the signing inputs, notify users about what they are signing and warn them in case of dangerous signing requests.

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a>.

> Comments like this are non-normative

### Overview

> This section is non-normative

ARC-60 defines a function `signData(signingData)` for signing structured data.

The input `signingData` encodes the following data:
- `scope`: The scope defines the schema of the structured data
- `data`: This is the structured data that needs to be signed
- `signer`: This is the public key of the signer that is requested to sign the data
- `hdPath`: This is an optional parameter that denotes the path used in a hierarchical deterministic (HD) wallet

In the following we show two examples of `signingData`, one uses a HD wallet and the other does not. In both cases we sign a random payload that uses the `MX_RANDOM` scope (defined below).

1. Sign data with a signer that the wallet knows:

```js
{
  "data": "TVj0AlqotomHsDbyQSr8mtxGAmFnKwdtX6Je5aa4Gcg="
  "signer": [14, 42, 18, 220, 70, 74, 199, 78, 195, 239, 113, 65, 163, 112, 75, 1, 168, 27, 70, 155, 155, 148, 55, 182, 6, 239, 199, 206, 42, 222, 21, 113],
  "scope": "MX_RANDOM"
}
```

2. Sign data with a hierarchical deterministic (HD) wallet:

```js
{
  "data": "TVgLSbLcpbgzpsaFgHK5dd1xKiWquruvWcWme/4nhlZ/JoC3ZsfR/geZMHr6vmWqLWdpbadEMfLTrE1oYeMs1g9y",
  "signer": [14, 42, 18, 220, 70, 74, 199, 78, 195, 239, 113, 65, 163, 112, 75, 1, 168, 27, 70, 155, 155, 148, 55, 182, 6, 239, 199, 206, 42, 222, 21, 113],
  "hdPath": {
    "purpose": 44, // hardened
    "coinType": 283, // hardened
    "account": 0, // hardened
    "change": 0,
    "addrIdx": 0
  },
  "scope": "MX_RANDOM"
}
```

The schema of the structured data (as identified by the `scope`) allows wallets to interpret the data, validate it, present it to the user, and serialize it into a byte string that can be signed. To this end, a schema must define three functions that wallets can use to process the data:
- `parse`: This function turns the input `data` (a string) into a structured object (e.g., a fixed-sized byte array, a JSON object, etc)
- `validate`: This function validates the input against a known schema for this scope and determines if an input is safe to sign
- `serialize`: This function deterministically serializes the structured data into a byte array that can be signed

Ultimately, the `signData` function returns the signature `Sig(serialize(parse(data)), sk)` where `sk` is the `signer`'s signing key.

### Data Models and Interfaces

We model data types and functions as TypeScript interfaces. All the objects that are defined are valid JSON objects.

ARC-60 uses interchangeably the terms "throw an error" and "reject a promise with an error".

#### **Interface `SignDataFunction`**

A wallet function `signData` is defined by the interface:

```ts
export type SignDataFunction = {
    signingData: StdSignData
} => Promise<Signature>;
```

The `signData` function, which takes a `StdSignData` object as input, returns a `Signature` object or, in case of error, rejects the promise with an error object `SignDataError`.


#### Interface `StdSignData`

A `StdSignData` object encodes the structured data to be signed by a wallet.

```ts
export interface StdSignData {
    /**
    * The scope value of the signing data request.
    */
    scope: ScopeType;

    /**
    * The arbitrary data structured accoring to the scope's schema.
    */
    data: string;

    /**
    * The signer ed25519 public key.
    */
    signer: Ed25519Pk;

    /**
    * Optional HD wallet metadata used to derive
    * the signer ed25519 public key.
    */
    hdPath?: HDWalletMetadata;
}
```

The `StdSignData` object contains the following data:
- `scope` identifies the schema of the structured data.
- `data` is the structured data that needs to be signed. The `data` is encoded as string for easy transportation.
- `signer` is a `Ed25519Pk` object (defined below) that represents the signer public key.
- `hdPath` is an optional `HDWalletMetadata` object (defined below) that represents the derivation path to obtain the `signer` public key in a HD wallet.



#### Interface `HDWalletMetadata`

An `HDWalletMetadata` specifies the derivation path parameters to derive the keys of an HD wallet from the seed.

> HD derivation levels originally from  <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-44</a>.

```ts
export interface HDWalletMetadata {
    /**
    * HD Wallet purpose value. First derivation path level.
    * Hardened derivation is used.
    */
    purpose: number;

    /**
    * HD Wallet coin type value. Second derivation path level.
    * Hardened derivation is used.
    */
    coinType: number;

    /**
    * HD Wallet account number. Third derivation path level.
    * Hardened derivation is used.
    */
    account: number;

    /**
    * HD Wallet change value. Fourth derivation path level.
    * Soft derivation is used.
    */
    change: number;

    /**
    * HD Wallet address index value. Fifth derivation path level.
    * Soft derivation is used.
    */
    addrIdx: number;
}
```

- `purpose` **SHOULD** be set to `44’` for blockchain accounts.
- `coinType` indicates a derivation subtree for a specific cryptocurrency. It **MUST** be set to `283’` for ALGO according to <a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">SLIP-44</a> registered coin types.

The apostrophe in the numbering convention indicates that hardened derivation is used.

#### Interface `Ed25519Pk`

An `Ed25519Pk` object is a 32-byte public key, point of the ed25519 elliptic curve. The key **MUST NOT** be transformed into an Algorand address.

```ts
export type Ed25519Pk = Uint8Array;
```

> The wallet **MAY** want to operate directly with standard Algorand addresses. The transformation from a generic key to an Algorand address is left to the implementation. See <a href="https://developer.algorand.org/docs/get-details/accounts/#transformation-public-key-to-algorand-address">Public Key to Algorand Address</a> section of the developer portal.

#### Interface `Signature`

`Signature` is the produced 64-byte array, ed25519 digital signature of the signed message.

```ts
export type Signature = Uint8Array;
```

#### Enum `ScopeType`

The `ScopeType` enumerates constant strings with the scope of a signing action. Any extension of this ARC **SHOULD** adopt an existing `ScopeType`, or introduce a new one.

This ARC introduces two scope types:

| ScopeType          | Description |
| -----------------  | ----------- |
| MX_RANDOM          | Random data but it's prefixed with the domain separator `MX`. |
| LSIG_TEMPLATE      | Signature of an Algorand program that compiles with a known template |

#### Error interface `SignDataError`

The `SignDataError` follows the same defined in [ARC-1](./arc-0001.md).

```ts
export class SignDataError extends Error {
  code: number;
  message: string;
  data?: any;
}
```

`SignDataError` uses the same error codes of `SignTxnsError` as well as the following codes:

| Status Code | Name | Description |
| --- | --- | --- |
| 4600 | Invalid scope | The scope of the signing action is not recognized by the wallet |
| 4601 | Doesn't match schema | The data does not adhere to the scope schema |
| 4602 | Failed parsing | Data cannot be parsed according to the schema |
| 4603 | Invalid signer | The signer is unknown to the wallet |
| 4604 | Invalid HD path | The HD path does not correspond to the signer public key |
| 4605 | Unkonwn error | An unknown error occurred |
| 4606 | Uknown LSIG template | The LSIG template is unknown to the wallet |


### Scopes and Schemas

Scopes and their accompanying schemas define the type of the data that a user is asked to sign (e.g., a fixed-sized nonce used for authentication, or a hash of a document, etc). This ARC comes only with one pre-defined scope and it is expected that if the requirement for new scopes arise, they are proposed in extensions of this ARC or in new ARCs.

A scope must define three functions that allow wallets to safely parse the structured data, validate it, and serialize it to a byte string to prepare it for signing. We call these three functions `parse`, `validate`, and `serialize`, respectively. A scope must make sure that a structured data type **MUST NOT** serialize to a valid transaction or logic signature (unless this is the intended use case for the scope).

In the following, we define the interfaces of these three functions as TypeScript interfaces for a generic scope that uses a structured data type `T` (this could be, e.g., a fixed-sized byte array, or a JSON object, etc).  Later, we show examples of actual scopes.

#### Function `parse`

Function `parse` is used to convert the input `StdSignData.data`, which is a string, to an instance of the structured data type `T`. It must fail if the data cannot be parsed.

```ts
export type ParseFunction = {
    encodedData: string
} => T;
```

#### Function `validate`

Function `validate` takes an instance of the structured data `T` as input and checks if it is valid according to a set of rules that are individual to each scope. For example, a validation function can check if the data has a certain size, if a domain matches, etc. Each scope must come with a precise set of validation rules that allows wallets to determine if the input is valid or not.

```ts
export type ValidateFunction = {
    structuredData: T
} => boolean;
```

#### Function `serialize`

Function `serialize` flattens an instance of the structured data `T` into a byte array that can be fed into a  signing function. It is important that this function is deterministic, meaning that two parties that serialize the same data receive the same byte array. This ensures that given an instance of `T`, a signer and a verifier operate on the same byte string.

```ts
export type SerializeFunction = {
    structuredData: T
} => Uint8Array;
```

#### Scope `MX_RANDOM`

This scope is inspired by the `signBytes` function in the Algorand SDK which is currently used by some applications. The `signBytes` function allows arbitrary data signing with the only restriction that the data is neither a valid transaction nor a logic signature. This is achieved by enforcing that the first two bytes are the domain separator `MX`. Apart from this restriction, the data is an opaque, unstructured byte string.

Functions `parse`, `validate`, and `serialize` can be defined as follows:

```ts
function parse(data: string): Uint8Array {
    return Buffer.from(data, 'base64');
}
function validate(data: Uint8Array): boolean {
    return data.length >= 2 && data[0] === 0x4D && data[1] === 0x58;
}
function serialize(data: Uint8Array): Uint8Array {
    return data;
}
```

Since the data is an opaque byte string, wallets cannot inform the user about the actual content that the user is asked to sign. Therefore, it is recommended that applications propose scopes with richer schemas that allow wallets to present more useful information to users.

#### EXAMPLE Scope `DOG_OWNERSHIP`

This scope is intended purely as an example to showcase how a scope with a stricter schema can be signed. The `DOG_OWNERSHIP` scope signs a JSON object that states that a person owns a dog:

```ts
export interface DogOwnership {
    ownerName: string;
    dogChipNumber: string;
}
```

We assume that a dog's chip number must be a 15-digit number and that the onwer name must be between 1 and 50 characters long. A `DogOwnership` is serialized according to canonical JSON ([RFC8785](https://www.rfc-editor.org/rfc/rfc8785)), which is intended to seralize JSON deterministically for use in cryptographic operations (hashing, signing, etc). We assume there exists a function `toCanonicalJson` that serializes an object to a byte array according to RFC8785.

```ts
function parse(data: string): DogOwnership {
  return JSON.parse(data);
}
function validate(data: DogOwnership): boolean {
  return /^\d{15}$/g.test(data.dogChipNumber)
    && data.ownerName.length >= 1
    && data.ownerName.length <= 50;
}
function serialize(data: DogOwnership): Uint8Array {
  return toCanonicalJson(data);
}
```


## Semantic Requirements

Upon calling `signData(signingData)`:
- the wallet **MUST** parse, validate, and serialize `signingData.data` as defined by the schema for scope `signingData.scope`
- the wallet **MUST** ask users for signing confirmation. It **MUST** display a message (defined in section Display message below) providing the `scope`, `signer`, and the `data` being signed:
  - if the user approves, `data` **MUST** be signed with the `signer`'s key and the resulting `Signature` must be returned.
  - if the user rejects, the call **MUST** fail with error code `4001`.

### Semantics of `StdSignData`

- it **MUST** be a valid `StdSignData` object, otherwise the wallet **MUST** reject.
- `data`:
  - it **MUST** be a valid UTF-8 encoded string, otherwise the wallet **MUST** reject.
- `signer`:
  - it **MUST** be a valid `Ed25519Pk` object, otherwise the wallet **MUST** reject.
  - the wallet **MUST** reject if the `signer` is unknown.
  - if `hdPath` is specified, the wallet **MUST** reject if `signer` does not correspond the public key derived with the `hdPath` parameters.
- `hdPath`:
  - The wallet **MAY** not support this field. In that case, it **MUST** throw a `4200` error.
  - if specified, it **MUST** be a valid `HDWalletMetadata` object, otherwise the wallet **MUST** reject.
  - if specified and supported, the wallet **MUST** verify that the derivation path resolves to a public key corresponding to `signer`.
- `scope`:
  - it **MUST** be a valid `ScopeType` string, otherwise the wallet **MUST** throw a `4600` error.


### Display message

The wallet **MUST** display a message for any signing request. The message **MUST** be computed dynamically taking as inputs the `scope`, the `signer`, and the data being signed `data`.

> The message is left to the implementation. An example is:
>
> `You are about to sign <data> with scope <scope> and signer <signer>`.


## Rationale

This API was designed to enable the secure signing of structured data with Algorand wallets. The API:

- Is generic to _pure_ ed25519 key pairs and does not require key manipulation
- Is easy to extend with custom schemas to support future signing use cases (e.g. authentication)
- Is secure by design preventing malicious applications from tricking users into signing malicious data or in the worst cases approving malicious transactions.

This API was not designed to sign Algorand transactions or a group of transactions (see ARC-1 instead).

## Backwards Compatibility

N/A

## Test Cases

The reference implementation, available in folder `../assets/arc-0060`, is equipped with a test suite that includes a number of test cases.

## Reference Implementation

A reference implementation is available in the `../assets/arc-0060` folder.

## Security Considerations

Users signing bytes can be tricked into signing malicious messages being exposed to man-in-the-middle attacks.  Users must be aware of what they are signing and for what purpose: this is defined through the scope and the data that is sigend.  Wallets only support known `ScopeTypes` and schemas. It ensures that signing actions have a clear scope and mitigates the risk of producing unexpected signatures.

## Copyright

Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.